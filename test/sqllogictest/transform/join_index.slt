# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

statement ok
DROP TABLE IF EXISTS foo;

statement ok
DROP TABLE IF EXISTS bar;

statement ok
CREATE TABLE foo(a int, b int)

statement ok
INSERT INTO foo VALUES (1, 2), (-1, 4), (null, 3)

statement ok
CREATE TABLE bar(a int, b int)

statement ok
INSERT INTO bar VALUES (1, 3), (-1, null), (null, 5)

# no indexes other than the default foo(a,b) and bar(a,b)
query T multiline
EXPLAIN PLAN FOR select * from foo inner join bar on foo.a = bar.a where foo.a = 1
----
Source materialize.public.foo (u1):
| Filter (#0 = 1)
| Project (#0, #1)

Source materialize.public.bar (u2):
| Filter (#0 = 1)
| Project (#0, #1)

Query:
%0 =
| Get materialize.public.foo (u1)
| Filter (#0 = 1)
| ArrangeBy ()

%1 =
| Get materialize.public.bar (u2)
| Filter (#0 = 1)

%2 =
| Join %0 %1
| | implementation = Differential %1 %0.()

EOF

query IIII
select * from foo inner join bar on foo.a = bar.a where foo.a = 1
----
1
2
1
3

# no indexes other than the default foo(a,b) and bar(a,b)
query T multiline
EXPLAIN PLAN FOR select * from foo inner join bar on foo.a = abs(bar.a) where mod(foo.a, 2) = 1
----
Source materialize.public.foo (u1):
| Filter (1 = (#0 % 2))
| Project (#0, #1)

Source materialize.public.bar (u2):
| Filter (1 = (abs(#0) % 2))
| Project (#0, #1)

Query:
%0 =
| Get materialize.public.foo (u1)
| Filter (1 = (#0 % 2))
| ArrangeBy (#0)

%1 =
| Get materialize.public.bar (u2)
| Filter (1 = (abs(#0) % 2))

%2 =
| Join %0 %1 (= #0 abs(#2))
| | implementation = Differential %1 %0.(#0)

EOF

query IIII
select * from foo inner join bar on foo.a = abs(bar.a) where mod(foo.a, 2) = 1
----
1
2
-1
NULL
1
2
1
3

# Test that column knowledge can propagate across inputs of a join.
# no indexes other than the default foo(a,b) and bar(a,b)
query T multiline
EXPLAIN PLAN FOR select * from (select * from foo where a = 1) filtered_foo, bar where filtered_foo.a = bar.a
----
Source materialize.public.foo (u1):
| Filter (#0 = 1)
| Project (#0, #1)

Source materialize.public.bar (u2):
| Filter (#0 = 1)
| Project (#0, #1)

Query:
%0 =
| Get materialize.public.foo (u1)
| Filter (#0 = 1)
| ArrangeBy ()

%1 =
| Get materialize.public.bar (u2)
| Filter (#0 = 1)

%2 =
| Join %0 %1
| | implementation = Differential %1 %0.()

EOF

query IIII
select * from (select * from foo where a = 1) filtered_foo, bar where filtered_foo.a = bar.a
----
1
2
1
3

statement ok
CREATE INDEX foo_idx on foo(a);

statement ok
CREATE INDEX bar_idx on bar(a);

statement ok
CREATE TABLE baz(a int primary key, b int)

statement ok
INSERT INTO baz VALUES (3, 0), (5, 2)

# indexes exist on foo(a), bar(a), and baz(a). baz(a) is a unique key
query T multiline
EXPLAIN PLAN FOR
select foo.a, baz.b
from foo, bar, baz
where foo.a = bar.a
  and baz.a = bar.b
----
Source materialize.public.baz (u5):
| Project (#0, #1)

Query:
%0 =
| Get materialize.public.foo (u1)
| ArrangeBy (#0)

%1 =
| Get materialize.public.bar (u2)
| Filter (#0) IS NOT NULL, (#1) IS NOT NULL

%2 =
| Get materialize.public.baz (u5)
| ArrangeBy (#0)

%3 =
| Join %0 %1 %2 (= #0 #2) (= #3 #4)
| | implementation = Differential %1 %2.(#0) %0.(#0)
| Project (#0, #5)

EOF

query II
select foo.a, baz.b
from foo, bar, baz
where foo.a = bar.a
  and baz.a = bar.b
----
1
0

statement ok
DROP TABLE baz

statement ok
CREATE TABLE baz(a int, b int)

statement ok
INSERT INTO baz VALUES (3, 0), (5, 2), (null, 6)

statement ok
CREATE INDEX baz_idx on baz(a);

# indexes exist on foo(a), bar(a), and baz(a)
query T multiline
EXPLAIN PLAN FOR
select foo.a, baz.b
from foo, bar, baz
where foo.a = bar.a
  and baz.a = bar.b
----
%0 =
| Get materialize.public.foo (u1)
| ArrangeBy (#0)

%1 =
| Get materialize.public.bar (u2)
| ArrangeBy (#0)

%2 =
| Get materialize.public.baz (u6)
| ArrangeBy (#0)

%3 =
| Join %0 %1 %2 (= #0 #2) (= #3 #4)
| | implementation = Differential %1.(#0) %0.(#0) %2.(#0)
| Filter (#0) IS NOT NULL, (#3) IS NOT NULL
| Project (#0, #5)

EOF

query II
select foo.a, baz.b
from foo, bar, baz
where foo.a = bar.a
  and baz.a = bar.b
----
1
0

statement ok
CREATE INDEX foo_idx2 on foo(nullif(a, 0));

statement ok
CREATE INDEX bar_idx2 on bar(-a);

# Test that when join planning uses indexes on expressions.
# Protects against regression of #4170.
query T multiline
EXPLAIN PLAN FOR
select foo.b, bar.b
from foo, bar
where nullif(foo.a, 0) = -bar.a
----
%0 =
| Get materialize.public.foo (u1)
| ArrangeBy (if (#0 = 0) then {null} else {#0})

%1 =
| Get materialize.public.bar (u2)
| ArrangeBy (-(#0))

%2 =
| Join %0 %1 (= -(#2) if (#0 = 0) then {null} else {#0})
| | implementation = DeltaQuery
| |   delta %0 %1.(-(#0))
| |   delta %1 %0.(if (#0 = 0) then {null} else {#0})
| Filter (#2) IS NOT NULL, (if (#0 = 0) then {null} else {#0}) IS NOT NULL
| Project (#1, #3)

EOF

query II
select foo.b, bar.b
from foo, bar
where nullif(foo.a, 0) = -bar.a
----
2
NULL
4
3

statement ok
DROP INDEX bar_idx;

statement ok
CREATE INDEX bar_idx3 on bar(a + 4);

# In this test, there exists an index on bar(a + 4)
# but not bar(a). Check that bar(a+4) is not inappropriately
# substituted for bar(a) in the first equivalence.
query T multiline
EXPLAIN PLAN FOR
select foo.b, bar.b, baz.b
FROM bar, foo, baz
where foo.a = bar.a
  and bar.a + 4 = baz.a
----
%0 =
| Get materialize.public.bar (u2)
| ArrangeBy ((#0 + 4))

%1 =
| Get materialize.public.foo (u1)
| ArrangeBy (#0)

%2 =
| Get materialize.public.baz (u6)
| ArrangeBy (#0)

%3 =
| Join %0 %1 %2 (= #0 #2) (= #4 (#0 + 4))
| | implementation = Differential %2.(#0) %0.((#0 + 4)) %1.(#0)
| Filter (#0) IS NOT NULL, (#4) IS NOT NULL
| Project (#3, #1, #5)

EOF

query III
select foo.b, bar.b, baz.b
FROM bar, foo, baz
where foo.a = bar.a
  and bar.a + 4 = baz.a
----
4
NULL
0
2
3
2

# tests that equalities involving multi-input equalities become join conditions.

query T multiline
explain plan for select foo.b, bar.b from foo, bar, (select 1 as a) const where foo.a / bar.a = const.a
----
%0 =
| Get materialize.public.foo (u1)
| ArrangeBy ()

%1 =
| Get materialize.public.bar (u2)

%2 =
| Join %0 %1 (= 1 (#0 / #2))
| | implementation = Differential %1 %0.()
| Project (#1, #3)

EOF

query II
select foo.b, bar.b from foo, bar, (select 1 as a) const where foo.a / bar.a = const.a
----
4
NULL
2
3

query T multiline
explain plan for
select foo.b, bar.b
from foo, bar, (select -1 as a) const
where foo.a / bar.a = const.a
and bar.b - foo.b = foo.a / bar.a
----
%0 =
| Get materialize.public.foo (u1)
| ArrangeBy ()

%1 =
| Get materialize.public.bar (u2)

%2 =
| Join %0 %1 (= -1 (#3 - #1) (#0 / #2))
| | implementation = Differential %1 %0.()
| Project (#1, #3)

EOF

query II
select foo.b, bar.b
from foo, bar, (select -1 as a) const
where foo.a / bar.a = const.a
and bar.b - foo.b = foo.a / bar.a
----
4
3

statement ok
DROP INDEX baz_idx

# materialize#8002: it would be nice if this join used the indexes on foo(a)
# and bar(a+4)

query T multiline
EXPLAIN PLAN FOR
select foo.b, bar.b, baz.b
FROM foo, bar, baz
where foo.a = bar.a
  and foo.a + 4 = baz.a
----
Source materialize.public.baz (u6):
| Filter (#0) IS NOT NULL
| Project (#0, #1)

Query:
%0 =
| Get materialize.public.foo (u1)
| Filter (#0) IS NOT NULL
| ArrangeBy ((#0 + 4))

%1 =
| Get materialize.public.bar (u2)
| Filter (#0) IS NOT NULL
| ArrangeBy (#0)

%2 =
| Get materialize.public.baz (u6)
| Filter (#0) IS NOT NULL

%3 =
| Join %0 %1 %2 (= #0 #2) (= #4 (#0 + 4))
| | implementation = Differential %2 %0.((#0 + 4)) %1.(#0)
| Project (#1, #3, #5)

EOF

query III
select foo.b, bar.b, baz.b
FROM bar, foo, baz
where foo.a = bar.a
  and bar.a + 4 = baz.a
----
4
NULL
0
2
3
2

statement ok
CREATE TABLE t1 (f1 DOUBLE PRECISION, f2 DOUBLE PRECISION NOT NULL);

statement ok
CREATE INDEX t1i1 ON t1(f1);

statement ok
CREATE INDEX t1i2 ON t1(f2, f1);

# one NULL row in t1

statement ok
INSERT INTO t1 VALUES (NULL, 0);

# values 1 and 2 have 2 rows each in t1

statement ok
INSERT INTO t1 VALUES (1, 1), (1, 1), (2, 2), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8);

# value 9 not present in either table

statement ok
CREATE TABLE t2 (f1 DOUBLE PRECISION, f2 DOUBLE PRECISION NOT NULL);

statement ok
CREATE INDEX t2i1 ON t2(f1);

statement ok
CREATE INDEX i2i2 ON t2(f2, f1);

# two NULL rows in t2

statement ok
INSERT INTO t2 VALUES (NULL, 0), (NULL, 0), (1, 1);

# value 2 has 2 rows in t2
statement ok
INSERT INTO t2 VALUES (2, 2), (2, 2);

# value 3 has no rows in t2
statement ok
INSERT INTO t2 VALUES (4, 4), (5, 5), (6, 6), (7, 7), (8, 8);

query RRR
SELECT *
  FROM (
        SELECT AVG(f1) + 10000 AS agg1
          FROM t1
       ) a1,
       t1 a2
 WHERE a2.f2 > a1.agg1;
----

query RR rowsort
SELECT a2.f2, agg1
  FROM (
        SELECT AVG(f1)  AS agg1 FROM t1
       ) a1 ,
       t1 a2
 WHERE a2.f2 < a1.agg1;
----
0.000
3.900
1.000
3.900
1.000
3.900
2.000
3.900
2.000
3.900
3.000
3.900

query
SELECT  FROM (  SELECT  AVG ( f2  ) f2  FROM t2  )  JOIN (  SELECT a2 .f1  FROM t1  JOIN t1 a2  ON  TRUE  )  ON  TRUE  WHERE  TRUE  AND f1  = f2   ;
----

query B
SELECT a1 .f1  FROM (  SELECT  TRUE f1  , MAX ( f1  ) f2  FROM t2  ) a1  RIGHT  JOIN (  SELECT f1  FROM t2  )  ON f2  IN (  1  , f2  )   ;
----
true
true
true
true
true
true
true
true
true
true

query R
SELECT f1  FROM (  SELECT  2 f1  , MIN ( f2  ) f2  FROM t1  ) a1  RIGHT  JOIN (  SELECT f2  FROM t2  )  ON f1  = a1 .f2   ;
----
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL

# FilterCharacteristics and IndexedFilter

statement ok
CREATE TABLE big(a int not null, b int not null, c int not null, d int not null, e int not null, f int not null, g int not null, h int not null, i int not null, j int not null, k int not null, x int, y int, s string);

statement ok
CREATE INDEX big_idx_a on big(a);

statement ok
CREATE INDEX big_idx_b on big(b);

statement ok
CREATE INDEX big_idx_c on big(c);

statement ok
CREATE INDEX big_idx_d on big(d);

statement ok
CREATE INDEX big_idx_e on big(e);

statement ok
CREATE INDEX big_idx_f on big(f);

statement ok
CREATE INDEX big_idx_g on big(g);

statement ok
CREATE INDEX big_idx_h on big(h);

statement ok
CREATE INDEX big_idx_i on big(i);

statement ok
CREATE INDEX big_idx_j on big(j);

statement ok
CREATE INDEX big_idx_k on big(k);

statement ok
CREATE INDEX big_idx_y on big(y);

# Examine the last Delta path (%10):
# - From %9 to %5, there are decreasing FilterCharacteristics.
# - %2 to %4 are all in the any_filter category.
# - %0 and %1 don't have any filters.
query T multiline
EXPLAIN SELECT * FROM big as t0, big as t1, big as t2, big as t3, big as t4, big as t5, big as t6, big as t7, big as t8, big as t9, big as t10
WHERE
t0.a = t1.b AND
t1.b = t2.c AND
t2.c = t3.d AND
t3.d = t4.e AND
t4.e = t5.f AND
t5.f = t6.g AND
t6.g = t7.h AND
t7.h = t8.i AND
t8.i = t9.j AND
t9.j = t10.k AND
t9.x = 71 AND
t8.s LIKE 'a%' AND
t7.x IS NULL AND
t6.x BETWEEN 3 AND 8 AND
t5.x > 5 AND
t4.s NOT LIKE 'b%' AND
t3.x != t3.y AND
(NOT (t2.x = t2.y))
;
----
%0 =
| Get materialize.public.big (u17)
| ArrangeBy (#0)

%1 =
| Get materialize.public.big (u17)
| ArrangeBy (#1)

%2 =
| Get materialize.public.big (u17)
| ArrangeBy (#2)

%3 =
| Get materialize.public.big (u17)
| ArrangeBy (#3)

%4 =
| Get materialize.public.big (u17)
| ArrangeBy (#4)

%5 =
| Get materialize.public.big (u17)
| ArrangeBy (#5)

%6 =
| Get materialize.public.big (u17)
| ArrangeBy (#6)

%7 =
| Get materialize.public.big (u17)
| ArrangeBy (#7)

%8 =
| Get materialize.public.big (u17)
| ArrangeBy (#8)

%9 =
| Get materialize.public.big (u17)
| ArrangeBy (#9)

%10 =
| Get materialize.public.big (u17)
| ArrangeBy (#10)

%11 =
| Join %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %10 (= #0 #15 #30 #45 #60 #75 #90 #105 #120 #135 #150)
| | implementation = DeltaQuery
| |   delta %0 %9.(#9) %8.(#8) %7.(#7) %6.(#6) %5.(#5) %2.(#2) %3.(#3) %4.(#4) %1.(#1) %10.(#10)
| |   delta %1 %9.(#9) %8.(#8) %7.(#7) %6.(#6) %5.(#5) %2.(#2) %3.(#3) %4.(#4) %0.(#0) %10.(#10)
| |   delta %2 %9.(#9) %8.(#8) %7.(#7) %6.(#6) %5.(#5) %3.(#3) %4.(#4) %0.(#0) %1.(#1) %10.(#10)
| |   delta %3 %9.(#9) %8.(#8) %7.(#7) %6.(#6) %5.(#5) %2.(#2) %4.(#4) %0.(#0) %1.(#1) %10.(#10)
| |   delta %4 %9.(#9) %8.(#8) %7.(#7) %6.(#6) %5.(#5) %2.(#2) %3.(#3) %0.(#0) %1.(#1) %10.(#10)
| |   delta %5 %9.(#9) %8.(#8) %7.(#7) %6.(#6) %2.(#2) %3.(#3) %4.(#4) %0.(#0) %1.(#1) %10.(#10)
| |   delta %6 %9.(#9) %8.(#8) %7.(#7) %5.(#5) %2.(#2) %3.(#3) %4.(#4) %0.(#0) %1.(#1) %10.(#10)
| |   delta %7 %9.(#9) %8.(#8) %6.(#6) %5.(#5) %2.(#2) %3.(#3) %4.(#4) %0.(#0) %1.(#1) %10.(#10)
| |   delta %8 %9.(#9) %7.(#7) %6.(#6) %5.(#5) %2.(#2) %3.(#3) %4.(#4) %0.(#0) %1.(#1) %10.(#10)
| |   delta %9 %8.(#8) %7.(#7) %6.(#6) %5.(#5) %2.(#2) %3.(#3) %4.(#4) %0.(#0) %1.(#1) %10.(#10)
| |   delta %10 %9.(#9) %8.(#8) %7.(#7) %6.(#6) %5.(#5) %2.(#2) %3.(#3) %4.(#4) %0.(#0) %1.(#1)
| Filter (#109) IS NULL, "a%" ~~(#125), (#137 = 71), (#95 <= 8), (#81 > 5), (#95 >= 3), NOT("b%" ~~(#69)), (#39 != #40), (#53 != #54)
| Project (#0..=#14, #0, #16..=#29, #0, #31..=#44, #0, #46..=#59, #0, #61..=#74, #0, #76..=#89, #0, #91..=#104, #0, #106..=#119, #0, #121..=#134, #0, #136..=#149, #0, #151..=#153)

EOF

# IndexedFilter should
# - come before like (i.e., same category as literal_equality)
# - not prevent planning a Delta join
query T multiline
EXPLAIN SELECT * FROM big as t0, big as t1, big as t2
WHERE
t0.a = t1.b AND
t1.b = t2.c AND
t1.y = 42 AND
t0.s LIKE 'a%'
;
----
%0 =
| Get materialize.public.big (u17)
| ArrangeBy (#0)

%1 =
| Get materialize.public.big (u17)
| ArrangeBy (#12)

%2 =
| Constant (42)

%3 =
| Join %1 %2 (= #12 #14)
| | implementation = IndexedFilter (#12 = 42)
| ArrangeBy (#1)

%4 =
| Get materialize.public.big (u17)
| ArrangeBy (#2)

%5 =
| Join %0 %3 %4 (= #0 #15 #31)
| | implementation = DeltaQuery
| |   delta %0 %3.(#1) %4.(#2)
| |   delta %3 %0.(#0) %4.(#2)
| |   delta %4 %3.(#1) %0.(#0)
| Filter "a%" ~~(#13)
| Project (#0..=#14, #0, #16..=#27, #29, #30, #0, #32..=#42)

EOF
